# 线程

- 为什么还需要线程？

1. 进程需要切换
CPU寄存器要切换、虚拟地址和物理地址的映射要切换，即：上下文切换、页表切换
2. 进程间通信麻烦

## 概述

### 线程 轻量级的进程

1. 线程是一个正在执行的程序
2. 同一个进程存在多个线程，多个线程共享内存资源

**tips1：**
![](images/2023-10-11-10-54-50.png)
- 线程也会有上下文状态：内含PC指针和STACK指针
- 同一个进程的多个线程
  - 数据段、代码段共享，
  - 为了避免彼此影响，会有自己的栈(保证函数调用等不会干扰)

**tips2：**

1. 用户级线程：调度由进程自己分配
2. 内核级线程：调度由OS分配

- CPU调度以线程为单位，之前的进程可以看成单线程进程

- 在linux中，进程控制块和线程控制块一样，每个进程和线程都有自己的task_struct ， (区分：看是否独占地址空间)
- linux中，需要先创建进程，在进程内创建线程

1. 减少了上下文切换的代价(跟地址转换有关的都不用变了)
2. 不需要页表切换
3. 同一进程内部的线程通信简单(彼此都是共享内存)

> 在Linux文件系统中，路径 /proc 挂载了一个伪文件系统，通过这个伪文件系统用户可以采用访问普通文件的方式（使用read系统调用等），来访问操作系统内核的数据结构。其中，
> 在 /proc/[num] 目录中，就包含了pid为num的进程的大量的内核数据。
> 而在 /proc/[num]/task 就包含本进程中所有线程的内核数据。我们之前的编写进程都可以看成是单线程进程。

**tips3:**
链接时要加上 -pthread ， 否则会报错链接错误


### 线程库的历史

NPTL 从用户态1：1复刻到内核态

### 多线程下不能使用perror

- 一个典型的报错
- 
- 1. return -1
- 2. 修改**全局变量**errno ，打印错误字符串
  - errno依赖的内存在数据段，多线程共享
  - 所以存在竞争条件，并发访问的问题

- 栈是独享的：**多线程用返回值的数值(在栈上)来确定报错的类型**

可以使用`char *strerror(int errno)` 将返回值转换为字符串类型

```C
#define THREAD_ERROR_CHECK(ret, msg)                       \
    {                                                      \
        if (ret != 0)                                      \
        {                                                  \
            fprintf(stderr, "%s%s\n", msg, strerror(ret)); \
        }                                                  \
    }
```

## 线程的创建和终止

![](images/2023-10-11-10-54-22.png)

### 创建子线程

一启动进程，就创建了主线程.栈区从main开始压栈

主线程中执行**pthread_create**函数，创建子进程

```C
//1. 创建子线程
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);
//线程id， 线程属性 默认NULL， 线程启动函数(参数和返回值类型都是void*) 其地位：子线程的main函数， 传给start_routine的参数

//2. 获取子线程的线程id
pthread_self()；
```

- 调用

```C
#include<43func.h>
void *threadFunc(void *arg){
    printf("i am child therad, tid = %lu\n",pthread_self());
}
int main(){
    printf("i am main therad , tid = %lu\n",pthread_self());
    pthread_t tid;
    pthread_create(&tid,NULL,threadFunc,NULL);
    sleep(1);
    return 0;
}
```

**主线程终止，整个进程终止**

- 如果注释掉sleep(1)，只打印主线程信息
- 如果改为usleep(20)，可能两行可能三行

![](images/2023-10-11-11-23-38.png)

### 创建最多个线程并使用错误检查

- 可以创建的线程数跟栈区大小有关，受限于虚拟内存大小
```C
#include <43func.h>
void * threadFunc(void *arg){
    //printf("I am child thread, tid = %lu\n", pthread_self());
    while(1){
        sleep(1);
    }
}
int main(){
    pthread_t tid;
    for(int i = 0;;++i){
        int ret = pthread_create(&tid,NULL,threadFunc,NULL);
        THREAD_ERROR_CHECK(ret,"pthread_create");
        if(ret != 0){
            printf("i = %d\n", i);
            break;
        }
    }
}
```
### 代码检测线程的特性

#### 线程是并发执行的

![](images/2023-10-11-15-08-13.png)

#### 多线程是共享内存地址空间

![](images/2023-10-11-15-44-36.png)

#### 多线程共享堆空间

更好的实现方式传递参数：
pthread_create(tid,NULL,threadFunc,____)

> 需要多次指针类型转换。

```C
#include <43func.h>
void * threadFunc(void *arg){
    printf("I am child thread, tid = %lu\n", pthread_self());
    int *pHeap = (int *)arg;
    *pHeap = 100;
    printf("child thread, *pHead = %d\n", *pHeap);
}
int main(){
    printf("I am main thread, tid = %lu\n", pthread_self());
    int *pHeap = (int *)malloc(sizeof(int));
    *pHeap = 0;
    pthread_t tid;
    int ret = pthread_create(&tid,NULL,threadFunc,(void *)pHeap);
    THREAD_ERROR_CHECK(ret,"pthread_create");
    sleep(1);
    printf("main thread, *pHead = %d\n", *pHeap);
}
```

### void *可以当指针用也可以当long用

- 多线程的栈区是相对独立的
- 一个线程可以通过地址去访问另一个线程的栈区

#### 多线程之间传递一个整数

- 传递：传长整型
直接传递一个long类型——**干脆把void*当整型long来用**

```C
#include <43func.h>
void * threadFunc(void *arg){
    long i = (long) arg;//把arg转回long类型
    printf("I am child thread, tid = %lu, i = %ld\n", pthread_self(), i);
}
int main(){
    pthread_t tid;
    long i = 1;
    int ret = pthread_create(&tid,NULL,threadFunc,(void *)i);//把long类型转为void *
    THREAD_ERROR_CHECK(ret,"pthread_create");
    i = 2;//主线程改变id
    ret = pthread_create(&tid,NULL,threadFunc,(void *)i);
    THREAD_ERROR_CHECK(ret,"pthread_create");
    printf("I am main thread, tid = %lu, i = %ld\n", pthread_self(), i);
    sleep(2);
}
```
> 这种方式只是传递数据，不会共享
> 主线程改变，子线程不跟着变


#### 多线程之间共享一个整数

- 共享：穿指针
```C
#include <43func.h>
void * threadFunc(void *arg){
    long *pi = (long *) arg;//解引用
    printf("I am child thread, tid = %lu, i = %ld\n", pthread_self(), *pi);//解引用
}
int main(){
    pthread_t tid;
    long i = 1;
    int ret = pthread_create(&tid,NULL,threadFunc,(void *)&i);//取地址
    THREAD_ERROR_CHECK(ret,"pthread_create");
    i = 2;
    ret = pthread_create(&tid,NULL,threadFunc,(void *)&i);
    THREAD_ERROR_CHECK(ret,"pthread_create");
    sleep(2);
}
```

### 线程的终止

1. 调用之前学的进程终止都会导致整个进程终止，其中的所有线程终止
   1. main 里return
   2. exit
   3. _exit/_Exit
   4. abort
   5. 收到信号
2. 子线程如何只终止自己
   1. 从threadFunc中return (return NULL)(1尽量不要用这个)
   2. 任意位置调用`void pthread_exit(void *retval);`，其中参数为子进程的返回值


#### pthread_join 回收线程的资源

调用 pthread_join 可以**使本线程处于等待状态，直到指定的 thread 终止**，就结束等待，并且捕获到的线程终止状态存入 retval 指针所指向的内存空间中。
![](images/2023-10-11-16-14-46.png)
```C
int pthread_join(pthread_t thread, void **retval);
//目标线程的tid，不是一个指针；

//因为线程的终止状态是一个 void * 类型的数据
//调用join 想修改主调函数的void* ，所以间接修改、传递地址
```
- join和exit 的例子

```C
#include<43func.h>
void *threadFunc(void *arg){
    printf("i am child therad, tid = %lu\n",pthread_self());
    //return (void *) 10;
    pthread_exit((void *)234);
}
int main(){
    printf("i am main therad , tid = %lu\n",pthread_self());
    pthread_t tid;
    int ret = pthread_create(&tid,NULL,threadFunc,NULL);
    THREAD_ERROR_CHECK(ret,"pthread_create");
    /*
    写法1：
    long retval;//主线程申请8字节空间
    pthread_join(tid,(void **)&retval);//取地址传进去
    //主线程要拿&retval所指的内存空间存储子线程的返回值
    printf("retval = %ld\n",retval);
    */

    /*写法2：
    void *retval;
    pthread_join(tid,&retval);
    printf("retval = %ld\n",(long) retval);
    */

    //如果不想获取子线程的终止状态,阻塞线程知道tid线程终止
    //修改子线程return 变成exit
    pthread_join(tid,NULL);
    return 0;
}    
```
> 在使用 pthread_join 要特别注意参数的类型， thread 参数是不需要取地址的，如果参数错误，有些
情况下可能会陷入无限等待，还有些情况会立即终止，触发报错。
> ![](images/2023-10-11-16-50-30.png)

## 线程的取消和资源清理

### 线程的取消

- 多线程和信号不能同时使用
![](images/2023-10-11-16-53-01.png)

- 应该使用pthread_cancel 类似信号






