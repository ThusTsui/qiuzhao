# 进程间通信 IPC
在多个进程之间，如果需要进行通信的话，隔离特性会造成一些通信的障碍。所以我们需要一些手段来跨越隔离，实现进程间通信。
- 打破进程间的隔离，从而进程间可以共享数据

- **管道**
- 共享内存(难)
- 信号量(难)
- 消息队列
- **信号**

## 管道
1. 有名管道：在文件系统中存在一个管道文件
2. 匿名管道：在文件系统中不存在
   1. 只用于父子进程间

### popen (用的很少)
先使用 fork 创建一个子进程，父子进程之间用**管道**(两端是文件流)连接在一起
> 3号 库函数 跨平台 效率不高
> popen 库函数会首先使用 fork 创建一个子进程，并且在父子进程之间创建一根管道用于通信，然后调用 exec 执行command。command表示子进程要执行的shell命令。

```C
FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);
```
> type:
> "w":父进程可写入FILE；子进程读(把自己的STDIN 重定向为管道)
> 
> "r":父进程可读取FILE;子进程写(把自己的STDOUT 重定向为管道)

### pipe 系统调用(无名管道)

数组名做参数，长度是2 的int数组的数组名

pipe在内核态见两个对象，两个文件描述符描述它，对应管道读端(pipefd[0])和写端(pipefd[1])
- 图
自言自语，从1写入后自然而然从0读出来

#### 先pipe再fork

子进程也有两个文件描述符指向这两个文件对象——子进程读写，父进程写读——实现管道双向通信
- 单工通信：

1. 父 读 子 写：子进程[1]写，自然传到[0]，父进程[0]取出——子[0]父[1]可关闭
2. 父 写 子 读：父进程[1]写，自然传到[0]，子进程[0]取出——子[1]父[0]可
关闭
- 图


- 全双工：

消息打印的顺序是固定的 同步的——(read的阻塞导致)

- 图


### 有名管道的函数

1. mkdifo创建
2. unlink删除
3. rename改变名字/位置
4. link创建新的硬链接


## 共享内存
效率最高的(多)进程间通信——极端需要效率时使用

让两个虚拟内存的地址空间映射到同一片物理内存
改p1的虚拟页内存—>物理页修改->p2……pn的虚拟页随之修改

- 图

### 例子

- 库文件

- 图










