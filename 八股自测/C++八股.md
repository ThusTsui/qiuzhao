

1. **在main执行之前和之后执行的代码可能是什么？**
- 之前：初始化系统相关资源
    1. 设置栈指针
    2. 初始化静态static变量和global全局变量
    3. 将未初始化部分的全局变量赋初值（0、false、NULL）
    4. 全局对象初始化，在main之前调用构造函数
    5. 将main函数的参数argc、argv等传给main函数
    6. __attribute__((constructor))
- main函数执行后：
    1. 全局对象的析构函数
    2. atexit注册的函数会在main之后执行
    3. __attribute__((destructor))


2. **结构体内存对齐问题？（以后再背）**
- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同
- 未特殊说明时，按结构体中size最大的成员对齐
- C++11关键字：alignof 可以计算出类型的对齐方式，alignas 可以指定结构体的对齐方式（有些情况不可用，见[阿秀2.](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html)
- 暂略


3. **指针和引用的区别**
- 指针是一个变量，存储地址； 引用与原来变量本质是一个东西，是原变量的别名
- 指针可以多级； 引用只能有一级
- 指针可以为空； 引用不能为NULL且定义时必须初始化
- 指针生命和定义可以分开，可以改变指向； 引用声明必须初始化，且初始化后不可改变
- sizeof指针得到的是本指针大小； sizeof引用得到的是引用所指变量的大小
- 做参数时指针是值传递，函数内改变变量指向不影响实参； 引用会影响实参
- ？引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析


4. **在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？**
- 需要返回函数内局部变量内存的时候用指针(开辟内存记得释放); 返回局部变量的引用无意义
- 对栈空间大小敏感(如递归)的时候用引用，开销小
- 类对象做参数时候用引用

5. **堆和栈的区别**

栈：去饭馆吃饭，只管点菜(发出申请)、吃(使用)，不用管其他，快捷但是自由度小；
堆：自己动手做喜欢的菜，麻烦但是符合自己口味，自由度高
- 申请方式不同：
- 内存管理机制不同：
  ![](images/2023-09-05-18-37-07.png)
- 空间大小限制不同：
- 效率不同：
- 碎片问题：
- 生长方向：
- 分配方式：堆都是动态分配； 栈有静态/动态(alloca函数，但是释放由编译器进行)
- 分配效率

6. **堆快一点还是栈快一点？**

栈快
操作系统在底层对栈提供支持，分配专门的寄存器存放栈的地址，入栈出栈简单也有专门的指令执行，所以栈的效率高；
堆的操作由C++函数库提供的，分配内存时候需要算法寻找合适大小的内存。获取堆内容的时候需要两次访问：第一次访问指针，第二次根据指针的地址访问内存。


7. **区别以下指针类型？**
```C++
int *p[10]      //指针数组，强调数组，数组每个元素是一个指针
int (*p)[10]    //数组指针，强调指针，一个变量，指向一个数组大小10的int类型数组
int *p(int)     //函数声明 int符号占位，返回值int*类型
int (*p)(int)   //函数指针，指向的函数有int类型参数、返回值int类型
```
- 拓展
```C++
char *(* c[10])(int **p);
int (*(*(*pfunc)(int *))[5])(int *);
```

8. **new / delete 与 malloc / free的异同**

- 相同：都可用于内存的动态申请和释放
- 不同：
  - new/delete是C++运算符（关键字，直接由编译器支持），可以重载； malloc/free是C/C++语言标准库函数（需要库文件<cstdlib>支持）
  - new自动计算分配空间大小； malloc需要手工计算
  - new类型安全； malloc不是
  - new的实现过程（见下）； malloc均没有相关调用
  - new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前后会调用析构函数完成空间中资源的清理； 后者只分配释放内存
  - 前者可对数组用new[] 和delete[]； 后者只能对单个内存块管理


9.  **new和delete是如何实现的？**

new： 先调用 operator new(标准库函数)，分配足够大的原始空闲区域存储对象。找到后-运行构造函数来初始化构造对象-返回该块的指针；
delete：检查指针是否为空，确保不会删除一个未初始化或已经被删除的对象；非空-->对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存

10.  **malloc和new的区别？**

- malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型
- malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常


11.  **既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？**

对自定义类型需要：
![](images/2023-09-05-22-57-13.png)

12. **被free回收的内存是立即返还给操作系统吗？**

不是，被free回收的内存首先被ptmalloc使用双链表保护起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。(同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。)

13. **宏定义和函数有何区别？**

- 宏定义在预处理阶段完成替换，执行起来更快； 函数调用在运行时需要跳转到具体调用函数；
- 宏定义属于在结构中插入代码，无返回值； 函数调用具有返回值；
- 宏定义参数无类型 不进行类型检查； 函数相反
- 宏定义后面不加分号

14. **宏定义和typedef有何区别？**

- 宏主要用于定义常量；typedef主要用于定义类型别名
- 宏替换在预编译阶段，属于文本插入替换； typedef是编译的一部分
- 宏不进行类型检查； typedef有
- 宏不是语句，不在末尾加分号； typedef加
- **注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大**？

15. **变量声明和定义区别？**

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。

- 相同变量可以在多处声明（外部变量extern），但只能在一处定义。

16. **strlen和sizeof区别？**

- sizeof是运算符，不是函数，结果在编译时而非运行中获得； strlen是字符处理的库函数
- sizeof参数可以是任意数据类型； strlen参数只能是字符指针且结尾是'\0'的字符串
- sizeof值在编译时确定，因此不能用来得到动态分配（运行时分配）存储空间的大小
```C++
  int main(int argc, char const *argv[]){
      
      const char* str = "name";

      sizeof(str); // 取的是指针str的长度，是8
      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
      return 0;
  }
```

17. **常量指针和指针常量区别？**

- 指针常量：int const *p/ const int *p  *p不可变，即只想的是只读变量
- 常量指针：int* const p    p不可变，p是指针，即指向不可变

18. **a和&a有什么区别？**

- 假设数组int a[10]; int (*p)[10] = &a;其中：

    - a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
    - &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
    - 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。

19、C++和Python的区别
20、C++和C语言的区别